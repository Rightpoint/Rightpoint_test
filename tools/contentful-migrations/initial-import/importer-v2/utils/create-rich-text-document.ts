import { richTextFromMarkdown } from '@contentful/rich-text-from-markdown'
import { createOrUpdateAsset } from './create-or-update-entry'
import { getClientEnvironment } from './get-client-environment'
import { truncate } from './utils'
import { entryToLink } from './entry-to-link'
import {
    Document,
    Block,
    Inline,
    Text,
    BLOCKS,
} from '@contentful/rich-text-types'
import { get } from 'lodash'

const TurndownService = require('turndown')

export const createRichTextDocumentFromHtml = async (html: string) => {
    console.log('BEGIN RICH TEXT FROM HTML')

    const turndownService = new TurndownService()
    /**
     * Transform headings to H2s
     */
    turndownService.addRule('headings', {
        filter: ['h3', 'h4', 'h5', 'h6'],
        replacement: (content) => {
            console.log('REPLACING HEADING', content)
            return '## ' + content + '\n\n'
        },
    })

    const markdown = turndownService.turndown(html)
    // https://github.com/contentful/rich-text/tree/master/packages/rich-text-from-markdown
    const richTextDocument = await richTextFromMarkdown(
        markdown,
        async (node) => {
            console.log('-- RICH TEXT: Unsupported node found:', node)
            /**
             * If an image node is detected, create an asset and
             * convert to an embedded asset reference
             */
            if (node.type === 'image') {
                console.log('-- RICH TEXT: Found image node:', node)
                const asset = await createOrUpdateAsset({
                    environment: await getClientEnvironment(),
                    title: ``,
                    description: '',
                    // RP urls have spaces
                    url: encodeURI((node as any).url),
                    domain: 'https://www.rightpoint.com',
                } as any)
                if (!asset) {
                    return null
                }
                return {
                    nodeType: BLOCKS.EMBEDDED_ASSET,
                    content: [
                        // remove the text content.
                    ],
                    data: {
                        target: entryToLink(asset, 'Asset'),
                    },
                }
            }
            return null
        }
    )

    return await postProcessRichTextDocument(richTextDocument)
}

/**
 * Post process the rich text document generated by html->markdown->contentful tool.
 *
 * Some things are not caught; such as images being injected as text nodes in the following format:
 * ![](/-/media/high scale adobe commerce in the wild image 4.png?la=en)
 *
 * This function finds these nodes and:
 *
 * - Uploads asset
 * - Replace the text node with a link to the asset
 */
const postProcessRichTextDocument = async (document: Document) => {
    /**
     *
     * Block is a type that contains nodeTypes that are of BLOCK enum
     * Inline is a type that contains nodeTypes that are of INLINE enum
     */
    let imageCount = 1
    type ContentContainingNodeTypes = Block | Inline | Document
    type Nodes = Inline | Block | Document | Text
    async function recurse<T>(node: T)
    async function recurse(node: Nodes) {
        /**
         * If there's content, they are an array of nodes.
         */
        const isDocumentBlockOrInline = (
            node
        ): node is ContentContainingNodeTypes => !!node.content
        if (isDocumentBlockOrInline(node)) {
            const newContent = []
            /**
             * Await sequentially to avoid rate limiting
             */
            for await (const content of node.content) {
                newContent.push(await recurse(content))
            }
            node.content = newContent
        }

        const transformMarkdownFormattedImageNodes = async (node) => {
            /**
             * Check if this node contains a child text node
             * that contains a markdown formatted image
             */
            const isProbableMarkdownImage = (value) => value.includes('![]')
            const isParentOfChildWithMarkdown = (node) => {
                const child = get(node, 'content[0]')
                const childIsText = child && child.nodeType === 'text'
                const childIsMarkdownImage =
                    childIsText && isProbableMarkdownImage(child.value)
                return childIsMarkdownImage
            }

            /**
             * If so, upload the asset, and replace the node.
             */
            if (isParentOfChildWithMarkdown(node)) {
                const child = get(node, 'content[0]')
                const getMarkdownUrlRegex = new RegExp(
                    /!\[[^\]]*\]\((?<filename>.*?)(?=\"|\))(?<optional>\".*\")?\)/
                )
                const matches = getMarkdownUrlRegex.exec(child.value)
                const groups = matches.groups
                const filename = groups.filename

                const asset = await createOrUpdateAsset({
                    environment: await getClientEnvironment(),
                    title: ``,
                    description: '',
                    // RP urls have spaces
                    url: encodeURI(filename),
                    domain: 'https://www.rightpoint.com',
                } as any)

                imageCount += 1
                node = {
                    /**
                     * Both embedded entries and contentful Assets are of type 'embedded-entry'
                     */
                    nodeType: BLOCKS.EMBEDDED_ASSET,
                    content: [
                        // remove the old text content.
                    ],
                    data: {
                        target: entryToLink(asset, 'Asset'),
                    },
                }
            }
            return node
        }
        node = await transformMarkdownFormattedImageNodes(node)

        /**
         * Link transformation should be done later in a separate process
         * after all content is uploaded.
         *
         * We can transform links in various rich texts to reference entries instead of URLs.
         *
         * - Work link
         * - Article link
         * - We can also log links
         * - Or do this manually, as desired (latest conversation with Carie)
         */
        return node
    }
    return await recurse(document)
}
